/**
 * @file model.h
 * @brief Machine Learning Model generated by emlearn
 * @brief 由 emlearn 生成的机器学习模型 (Decision Tree / Random Forest)
 * * This file contains the logic for the anomaly detection decision trees.
 * 包含异常检测决策树的核心逻辑。
 */

#include <stdint.h>

// -----------------------------------------------------------------------------
// Decision Tree Logic Nodes
// 决策树逻辑节点
// -----------------------------------------------------------------------------

static inline int32_t anomaly_detector_tree_0(const float *features, int32_t features_length) {
    if (features[0] < 4.976395f) {
        return 0;
    } else {
        return 1;
    }
}

static inline int32_t anomaly_detector_tree_1(const float *features, int32_t features_length) {
    if (features[2] < 843.750000f) {
        if (features[2] < 54.687500f) {
            return 0;
        } else {
            if (features[2] < 679.687500f) {
                if (features[2] < 148.437500f) {
                    if (features[1] < 5.509623f) {
                        return 0;
                    } else {
                        return 1;
                    }
                } else {
                    if (features[0] < 4.410724f) {
                        return 0;
                    } else {
                        return 1;
                    }
                }
            } else {
                if (features[2] < 726.562500f) {
                    if (features[2] < 703.125000f) {
                        if (features[0] < 4.718688f) {
                            return 0;
                        } else {
                            return 1;
                        }
                    } else {
                        if (features[1] < 5.519731f) {
                            return 0;
                        } else {
                            return 1;
                        }
                    }
                } else {
                    if (features[1] < 5.462588f) {
                        return 0;
                    } else {
                        return 1;
                    }
                }
            }
        }
    } else {
        return 0;
    }
}

static inline int32_t anomaly_detector_tree_2(const float *features, int32_t features_length) {
    if (features[1] < 6.245472f) {
        return 0;
    } else {
        if (features[1] < 6.376458f) {
            if (features[1] < 6.276461f) {
                if (features[0] < 4.818744f) {
                    return 0;
                } else {
                    return 1;
                }
            } else {
                if (features[2] < 1390.625000f) {
                    return 1;
                } else {
                    return 0;
                }
            }
        } else {
            return 0;
        }
    }
}

static inline int32_t anomaly_detector_tree_3(const float *features, int32_t features_length) {
    if (features[2] < 789.062500f) {
        if (features[1] < 5.502961f) {
            return 0;
        } else {
            return 1;
        }
    } else {
        if (features[0] < 5.168046f) {
            return 0;
        } else {
            return 1;
        }
    }
}

static inline int32_t anomaly_detector_tree_4(const float *features, int32_t features_length) {
    if (features[2] < 828.125000f) {
        if (features[1] < 5.500753f) {
            return 0;
        } else {
            return 1;
        }
    } else {
        return 0;
    }
}

static inline int32_t anomaly_detector_tree_5(const float *features, int32_t features_length) {
    if (features[1] < 6.242415f) {
        return 0;
    } else {
        if (features[1] < 6.368943f) {
            if (features[1] < 6.276461f) {
                if (features[1] < 6.273966f) {
                    if (features[1] < 6.261928f) {
                        return 1;
                    } else {
                        if (features[2] < 2351.562500f) {
                            return 1;
                        } else {
                            return 0;
                        }
                    }
                } else {
                    return 0;
                }
            } else {
                if (features[1] < 6.333610f) {
                    if (features[0] < 4.796730f) {
                        return 0;
                    } else {
                        return 1;
                    }
                } else {
                    if (features[2] < 1468.750000f) {
                        return 1;
                    } else {
                        return 0;
                    }
                }
            }
        } else {
            if (features[1] < 6.386298f) {
                if (features[0] < 4.955077f) {
                    return 0;
                } else {
                    return 1;
                }
            } else {
                return 0;
            }
        }
    }
}

static inline int32_t anomaly_detector_tree_6(const float *features, int32_t features_length) {
    if (features[1] < 6.252241f) {
        return 0;
    } else {
        if (features[2] < 1390.625000f) {
            return 1;
        } else {
            return 0;
        }
    }
}

static inline int32_t anomaly_detector_tree_7(const float *features, int32_t features_length) {
    if (features[0] < 4.991418f) {
        return 0;
    } else {
        return 1;
    }
}

static inline int32_t anomaly_detector_tree_8(const float *features, int32_t features_length) {
    if (features[2] < 851.562500f) {
        if (features[1] < 5.490820f) {
            return 0;
        } else {
            return 1;
        }
    } else {
        return 0;
    }
}

static inline int32_t anomaly_detector_tree_9(const float *features, int32_t features_length) {
    if (features[0] < 4.976395f) {
        return 0;
    } else {
        return 1;
    }
}

static inline int32_t anomaly_detector_tree_10(const float *features, int32_t features_length) {
    if (features[0] < 4.976395f) {
        return 0;
    } else {
        return 1;
    }
}

static inline int32_t anomaly_detector_tree_11(const float *features, int32_t features_length) {
    if (features[2] < 789.062500f) {
        if (features[1] < 5.502961f) {
            return 0;
        } else {
            return 1;
        }
    } else {
        return 0;
    }
}

static inline int32_t anomaly_detector_tree_12(const float *features, int32_t features_length) {
    if (features[2] < 843.750000f) {
        if (features[0] < 4.454787f) {
            return 0;
        } else {
            return 1;
        }
    } else {
        return 0;
    }
}

static inline int32_t anomaly_detector_tree_13(const float *features, int32_t features_length) {
    if (features[2] < 914.062500f) {
        if (features[0] < 4.448852f) {
            return 0;
        } else {
            return 1;
        }
    } else {
        return 0;
    }
}

static inline int32_t anomaly_detector_tree_14(const float *features, int32_t features_length) {
    if (features[1] < 6.246624f) {
        return 0;
    } else {
        if (features[1] < 6.381849f) {
            if (features[0] < 4.891787f) {
                return 0;
            } else {
                return 1;
            }
        } else {
            if (features[1] < 6.386298f) {
                if (features[1] < 6.383260f) {
                    return 0;
                } else {
                    return 1;
                }
            } else {
                return 0;
            }
        }
    }
}

static inline int32_t anomaly_detector_tree_15(const float *features, int32_t features_length) {
    if (features[1] < 6.246624f) {
        return 0;
    } else {
        if (features[2] < 1398.437500f) {
            return 1;
        } else {
            return 0;
        }
    }
}

static inline int32_t anomaly_detector_tree_16(const float *features, int32_t features_length) {
    if (features[0] < 4.976395f) {
        return 0;
    } else {
        return 1;
    }
}

static inline int32_t anomaly_detector_tree_17(const float *features, int32_t features_length) {
    if (features[0] < 4.976395f) {
        return 0;
    } else {
        return 1;
    }
}

static inline int32_t anomaly_detector_tree_18(const float *features, int32_t features_length) {
    if (features[1] < 6.263591f) {
        if (features[0] < 5.030337f) {
            return 0;
        } else {
            return 1;
        }
    } else {
        if (features[0] < 4.976395f) {
            return 0;
        } else {
            return 1;
        }
    }
}

static inline int32_t anomaly_detector_tree_19(const float *features, int32_t features_length) {
    if (features[2] < 843.750000f) {
        if (features[2] < 46.875000f) {
            return 0;
        } else {
            if (features[1] < 5.490820f) {
                return 0;
            } else {
                return 1;
            }
        }
    } else {
        return 0;
    }
}

static inline int32_t anomaly_detector_tree_20(const float *features, int32_t features_length) {
    if (features[1] < 6.241782f) {
        return 0;
    } else {
        if (features[2] < 1398.437500f) {
            return 1;
        } else {
            return 0;
        }
    }
}

static inline int32_t anomaly_detector_tree_21(const float *features, int32_t features_length) {
    if (features[0] < 4.976395f) {
        return 0;
    } else {
        return 1;
    }
}

static inline int32_t anomaly_detector_tree_22(const float *features, int32_t features_length) {
    if (features[1] < 6.246196f) {
        return 0;
    } else {
        if (features[2] < 1414.062500f) {
            return 1;
        } else {
            return 0;
        }
    }
}

static inline int32_t anomaly_detector_tree_23(const float *features, int32_t features_length) {
    if (features[1] < 6.242415f) {
        return 0;
    } else {
        if (features[2] < 1414.062500f) {
            return 1;
        } else {
            return 0;
        }
    }
}

static inline int32_t anomaly_detector_tree_24(const float *features, int32_t features_length) {
    if (features[1] < 6.246624f) {
        return 0;
    } else {
        if (features[2] < 1398.437500f) {
            return 1;
        } else {
            return 0;
        }
    }
}

static inline int32_t anomaly_detector_tree_25(const float *features, int32_t features_length) {
    if (features[0] < 4.964317f) {
        return 0;
    } else {
        return 1;
    }
}

static inline int32_t anomaly_detector_tree_26(const float *features, int32_t features_length) {
    if (features[2] < 789.062500f) {
        if (features[1] < 5.500753f) {
            return 0;
        } else {
            return 1;
        }
    } else {
        if (features[2] < 835.937500f) {
            if (features[0] < 4.667444f) {
                return 0;
            } else {
                return 1;
            }
        } else {
            return 0;
        }
    }
}

static inline int32_t anomaly_detector_tree_27(const float *features, int32_t features_length) {
    if (features[1] < 6.259610f) {
        return 0;
    } else {
        if (features[1] < 6.386298f) {
            if (features[0] < 4.906810f) {
                return 0;
            } else {
                return 1;
            }
        } else {
            return 0;
        }
    }
}

static inline int32_t anomaly_detector_tree_28(const float *features, int32_t features_length) {
    if (features[0] < 4.976395f) {
        return 0;
    } else {
        return 1;
    }
}

static inline int32_t anomaly_detector_tree_29(const float *features, int32_t features_length) {
    if (features[1] < 6.246624f) {
        return 0;
    } else {
        if (features[1] < 6.369940f) {
            if (features[1] < 6.262617f) {
                if (features[1] < 6.260954f) {
                    if (features[2] < 2156.250000f) {
                        return 1;
                    } else {
                        return 0;
                    }
                } else {
                    return 0;
                }
            } else {
                if (features[1] < 6.362194f) {
                    if (features[0] < 4.818622f) {
                        return 0;
                    } else {
                        return 1;
                    }
                } else {
                    if (features[1] < 6.365108f) {
                        return 0;
                    } else {
                        return 1;
                    }
                }
            }
        } else {
            if (features[1] < 6.386298f) {
                if (features[0] < 5.093477f) {
                    return 0;
                } else {
                    return 1;
                }
            } else {
                return 0;
            }
        }
    }
}

// -----------------------------------------------------------------------------
// Main Prediction Interface
// 主预测接口
// -----------------------------------------------------------------------------

/**
 * @brief Predict class based on features using majority voting from trees.
 * @brief 基于特征预测类别（使用树的多数投票机制）。
 * * @param features Array of input features / 输入特征数组
 * @param features_length Length of the feature array / 特征数组长度
 * @return int32_t Predicted class index / 预测的类别索引
 */
int32_t anomaly_detector_predict(const float *features, int32_t features_length) {
    int32_t votes[2] = {0,};
    int32_t _class = -1;

    _class = anomaly_detector_tree_0(features, features_length); votes[_class] += 1;
    _class = anomaly_detector_tree_1(features, features_length); votes[_class] += 1;
    _class = anomaly_detector_tree_2(features, features_length); votes[_class] += 1;
    _class = anomaly_detector_tree_3(features, features_length); votes[_class] += 1;
    _class = anomaly_detector_tree_4(features, features_length); votes[_class] += 1;
    _class = anomaly_detector_tree_5(features, features_length); votes[_class] += 1;
    _class = anomaly_detector_tree_6(features, features_length); votes[_class] += 1;
    _class = anomaly_detector_tree_7(features, features_length); votes[_class] += 1;
    _class = anomaly_detector_tree_8(features, features_length); votes[_class] += 1;
    _class = anomaly_detector_tree_9(features, features_length); votes[_class] += 1;
    _class = anomaly_detector_tree_10(features, features_length); votes[_class] += 1;
    _class = anomaly_detector_tree_11(features, features_length); votes[_class] += 1;
    _class = anomaly_detector_tree_12(features, features_length); votes[_class] += 1;
    _class = anomaly_detector_tree_13(features, features_length); votes[_class] += 1;
    _class = anomaly_detector_tree_14(features, features_length); votes[_class] += 1;
    _class = anomaly_detector_tree_15(features, features_length); votes[_class] += 1;
    _class = anomaly_detector_tree_16(features, features_length); votes[_class] += 1;
    _class = anomaly_detector_tree_17(features, features_length); votes[_class] += 1;
    _class = anomaly_detector_tree_18(features, features_length); votes[_class] += 1;
    _class = anomaly_detector_tree_19(features, features_length); votes[_class] += 1;
    _class = anomaly_detector_tree_20(features, features_length); votes[_class] += 1;
    _class = anomaly_detector_tree_21(features, features_length); votes[_class] += 1;
    _class = anomaly_detector_tree_22(features, features_length); votes[_class] += 1;
    _class = anomaly_detector_tree_23(features, features_length); votes[_class] += 1;
    _class = anomaly_detector_tree_24(features, features_length); votes[_class] += 1;
    _class = anomaly_detector_tree_25(features, features_length); votes[_class] += 1;
    _class = anomaly_detector_tree_26(features, features_length); votes[_class] += 1;
    _class = anomaly_detector_tree_27(features, features_length); votes[_class] += 1;
    _class = anomaly_detector_tree_28(features, features_length); votes[_class] += 1;
    _class = anomaly_detector_tree_29(features, features_length); votes[_class] += 1;

    int32_t most_voted_class = -1;
    int32_t most_voted_votes = 0;
    for (int32_t i=0; i<2; i++) {
        if (votes[i] > most_voted_votes) {
            most_voted_class = i;
            most_voted_votes = votes[i];
        }
    }
    return most_voted_class;
}

/**
 * @brief Predict class probabilities.
 * @brief 预测各类别的概率。
 * * @param features Input features / 输入特征
 * @param features_length Feature length / 特征长度
 * @param out Output array for probabilities / 概率输出数组
 * @param out_length Output array length / 输出数组长度
 * @return int Status code / 状态码
 */
int anomaly_detector_predict_proba(const float *features, int32_t features_length, float *out, int out_length) {
    int32_t _class = -1;

    for (int i=0; i<out_length; i++) {
        out[i] = 0.0f;
    }

    _class = anomaly_detector_tree_0(features, features_length); out[_class] += 1.0f;
    _class = anomaly_detector_tree_1(features, features_length); out[_class] += 1.0f;
    _class = anomaly_detector_tree_2(features, features_length); out[_class] += 1.0f;
    _class = anomaly_detector_tree_3(features, features_length); out[_class] += 1.0f;
    _class = anomaly_detector_tree_4(features, features_length); out[_class] += 1.0f;
    _class = anomaly_detector_tree_5(features, features_length); out[_class] += 1.0f;
    _class = anomaly_detector_tree_6(features, features_length); out[_class] += 1.0f;
    _class = anomaly_detector_tree_7(features, features_length); out[_class] += 1.0f;
    _class = anomaly_detector_tree_8(features, features_length); out[_class] += 1.0f;
    _class = anomaly_detector_tree_9(features, features_length); out[_class] += 1.0f;
    _class = anomaly_detector_tree_10(features, features_length); out[_class] += 1.0f;
    _class = anomaly_detector_tree_11(features, features_length); out[_class] += 1.0f;
    _class = anomaly_detector_tree_12(features, features_length); out[_class] += 1.0f;
    _class = anomaly_detector_tree_13(features, features_length); out[_class] += 1.0f;
    _class = anomaly_detector_tree_14(features, features_length); out[_class] += 1.0f;
    _class = anomaly_detector_tree_15(features, features_length); out[_class] += 1.0f;
    _class = anomaly_detector_tree_16(features, features_length); out[_class] += 1.0f;
    _class = anomaly_detector_tree_17(features, features_length); out[_class] += 1.0f;
    _class = anomaly_detector_tree_18(features, features_length); out[_class] += 1.0f;
    _class = anomaly_detector_tree_19(features, features_length); out[_class] += 1.0f;
    _class = anomaly_detector_tree_20(features, features_length); out[_class] += 1.0f;
    _class = anomaly_detector_tree_21(features, features_length); out[_class] += 1.0f;
    _class = anomaly_detector_tree_22(features, features_length); out[_class] += 1.0f;
    _class = anomaly_detector_tree_23(features, features_length); out[_class] += 1.0f;
    _class = anomaly_detector_tree_24(features, features_length); out[_class] += 1.0f;
    _class = anomaly_detector_tree_25(features, features_length); out[_class] += 1.0f;
    _class = anomaly_detector_tree_26(features, features_length); out[_class] += 1.0f;
    _class = anomaly_detector_tree_27(features, features_length); out[_class] += 1.0f;
    _class = anomaly_detector_tree_28(features, features_length); out[_class] += 1.0f;
    _class = anomaly_detector_tree_29(features, features_length); out[_class] += 1.0f;

    // compute mean / 计算均值
    for (int i=0; i<out_length; i++) {
        out[i] = out[i] / 30;
    }
    return 0;
}